"""Generate decoding code of a schema inside a MCAP.

Usage:
uv run python -m mcap_ros2_support_fast.scripts.generate_code <mcap_file> -o output.py
"""

import argparse
from pathlib import Path

from mcap.reader import make_reader

from mcap_ros2_support_fast._dynamic_decoder import (
    DecoderGeneratorFactory,
)
from mcap_ros2_support_fast._dynamic_encoder import EncoderGeneratorFactory
from mcap_ros2_support_fast._planner import generate_plans, optimize_plan
from mcap_ros2_support_fast._plans import UTF8_FUNC_NAME


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("mcap_file", help="MCAP file to read schemas from")
    parser.add_argument(
        "-o", "--output", required=True, help="Output python file to write generated code to"
    )
    args = parser.parse_args()

    output_path = Path(args.output)
    output_path.parent.mkdir(exist_ok=True, parents=True)

    # Generate code for each schema
    decoder_factories = []
    encoder_factories = []
    seen_schemas: set[str] = set()
    decoder_functions = []
    encoder_functions = []

    with Path(args.mcap_file).open("rb") as f:
        reader = make_reader(f)
        summary = reader.get_summary()
        assert summary
        schemas = summary.schemas
        for schema in schemas.values():
            if schema.name in seen_schemas:
                continue
            seen_schemas.add(schema.name)
            plan = generate_plans(schema.name, schema.data.decode())
            optimized_plan = optimize_plan(plan)

            # Create decoder factory for this schema
            decoder_factory = DecoderGeneratorFactory(optimized_plan)
            decoder_func_name = f"decode_{schema.name.replace('/', '_')}"
            decoder_code = decoder_factory.generate_decoder_code(decoder_func_name)

            decoder_factories.append(decoder_factory)
            decoder_functions.append(decoder_code)

            # Create encoder factory for this schema
            encoder_factory = EncoderGeneratorFactory(optimized_plan)
            encoder_func_name = f"encode_{schema.name.replace('/', '_')}"
            encoder_code = encoder_factory.generate_encoder_code(encoder_func_name)

            encoder_factories.append(encoder_factory)
            encoder_functions.append(encoder_code)

    # Extract information needed for code generation
    all_decoder_struct_patterns = {}
    all_encoder_struct_patterns = {}
    all_message_classes = set()

    for factory in decoder_factories:
        all_decoder_struct_patterns.update(factory.struct_patterns)
        all_message_classes.update(factory.message_classes)

    for factory in encoder_factories:
        all_encoder_struct_patterns.update(factory.struct_patterns)
        all_message_classes.update(factory.message_classes)

    # Start building the complete output file
    generated_lines = [
        "# ruff: noqa",
        '"""This file is autogenerated, do not edit."""',
        "",
        "# Imports",
        "import codecs",
        "import dataclasses",
        "import struct",
        "import typing",
        "",
    ]

    # Add utility function definitions
    generated_lines.extend(
        [
            "# Utility functions",
            f"{UTF8_FUNC_NAME} = codecs.utf_8_decode",
            "_encode_utf8 = codecs.utf_8_encode",
            "_get_field = lambda obj, *field_path: (__import__('functools').reduce(lambda o, f: o[f] if isinstance(o, dict) else getattr(o, f), field_path, obj))",
            "",
        ]
    )

    # Add global struct patterns
    generated_lines.append("# Global struct patterns")

    # Decoder struct patterns (unpack_from)
    for pattern, var_name in all_decoder_struct_patterns.items():
        generated_lines.append(f"{var_name}g = struct.Struct('{pattern}').unpack_from")

    # Encoder struct patterns (pack)
    for pattern, var_name in all_encoder_struct_patterns.items():
        generated_lines.append(f"{var_name}g = struct.Struct('{pattern}').pack")

    generated_lines.append("")

    # Add message class definitions (avoid duplicates)
    generated_lines.append("# Message class definitions")
    seen_class_names = set()
    for msg_class in sorted(all_message_classes, key=lambda x: x.__name__):
        class_name = msg_class.__name__
        if class_name not in seen_class_names:
            seen_class_names.add(class_name)
            generated_lines.extend(generate_class_definition(msg_class))
    generated_lines.append("")

    # Add decoder functions
    generated_lines.append("# Decoder functions")
    for code in decoder_functions:
        generated_lines.append(code)
        generated_lines.append("")

    # Add encoder functions
    generated_lines.append("# Encoder functions")
    for code in encoder_functions:
        generated_lines.append(code)
        generated_lines.append("")

    # Add decoder registry
    generated_lines.append("# Decoder registry")
    generated_lines.append("DECODERS = {")
    for schema_name in sorted(seen_schemas):
        func_name = f"decode_{schema_name.replace('/', '_')}"
        generated_lines.append(f'    "{schema_name}": {func_name},')
    generated_lines.append("}")
    generated_lines.append("")

    # Add encoder registry
    generated_lines.append("# Encoder registry")
    generated_lines.append("ENCODERS = {")
    for schema_name in sorted(seen_schemas):
        func_name = f"encode_{schema_name.replace('/', '_')}"
        generated_lines.append(f'    "{schema_name}": {func_name},')
    generated_lines.append("}")
    generated_lines.append("")

    # Add factory functions
    generated_lines.extend(
        [
            "def get_decoder(schema_name: str):",
            "    return DECODERS.get(schema_name)",
            "",
            "def get_encoder(schema_name: str):",
            "    return ENCODERS.get(schema_name)",
            "",
        ]
    )

    # Write the complete file
    output_path.write_text("\n".join(generated_lines), encoding="utf-8")


def generate_class_definition(msg_class: type) -> list[str]:
    """Generate Python class definition for a message class."""
    lines = []

    # Extract class information
    class_name = msg_class.__name__
    slots = getattr(msg_class, "__slots__", [])
    type_info = getattr(msg_class, "_type", "unknown")
    full_text = getattr(msg_class, "_full_text", "")

    # Start class definition
    lines.append("@dataclasses.dataclass(slots=True)")
    lines.append(f"class {class_name}:")
    lines.append(f'    """Generated message class for {class_name}."""')
    lines.append(f"    _type: typing.ClassVar[str] = {type_info!r}")
    lines.append(f"    _full_text: typing.ClassVar[str] = {full_text!r}")
    lines.extend(f'    {slot}: "typing.Any"' for slot in slots)

    lines.append("")

    return lines


if __name__ == "__main__":
    main()
