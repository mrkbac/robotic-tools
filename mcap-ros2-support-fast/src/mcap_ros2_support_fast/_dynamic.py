"""ROS2 message execution engine for fast deserialization.

This module implements a plan-based parser that consumes execution plans
generated by _planner.py. It focuses purely on fast execution without
concern for plan generation logic.
"""

import array as py_array
from typing import Any

from ._cdr import CdrReader, CdrWriter

# cSpell:words ftype wstring msgdefs typecode tobytes
# Type aliases for compatibility
from ._plans import (
    ActionType,
    ComplexAction,
    ComplexArrayAction,
    DecodedMessage,
    DecoderFunction,
    DefaultValue,
    PlanList,
    PrimitiveAction,
    PrimitiveArrayAction,
    PrimitiveGroupAction,
    PrimitiveValue,
    TypeId,
)
from ._vendor.rosidl_adapter.parser import (
    Field,
    MessageSpecification,
)


def _parse_w_string(reader: CdrReader) -> str:
    raise NotImplementedError("wstring parsing is not implemented")


def _parse_w_string_array(reader: CdrReader, array_length: int) -> list[str]:
    raise NotImplementedError("wstring[] parsing is not implemented")


def _write_w_string(writer: CdrWriter, value: str) -> None:
    raise NotImplementedError("wstring writing is not implemented")


def _write_w_string_array(writer: CdrWriter, value: list[str]) -> None:
    raise NotImplementedError("wstring[] writing is not implemented")


def _read_padding(reader: CdrReader) -> None:
    """Read and discard a single padding byte."""
    reader.uint8()  # Read one byte and discard it


# TypeId to reader method mapping for fast dispatch
_TYPE_READERS = {
    TypeId.BOOL: CdrReader.boolean,
    TypeId.BYTE: CdrReader.uint8,
    TypeId.CHAR: CdrReader.int8,
    TypeId.FLOAT32: CdrReader.float32,
    TypeId.FLOAT64: CdrReader.float64,
    TypeId.INT8: CdrReader.int8,
    TypeId.UINT8: CdrReader.uint8,
    TypeId.INT16: CdrReader.int16,
    TypeId.UINT16: CdrReader.uint16,
    TypeId.INT32: CdrReader.int32,
    TypeId.UINT32: CdrReader.uint32,
    TypeId.INT64: CdrReader.int64,
    TypeId.UINT64: CdrReader.uint64,
    TypeId.STRING: CdrReader.string,
    TypeId.WSTRING: _parse_w_string,
    TypeId.PADDING: _read_padding,
}

# TypeId to array reader method mapping for fast dispatch
_TYPE_ARRAY_READERS = {
    TypeId.BOOL: CdrReader.boolean_array,
    TypeId.BYTE: CdrReader.uint8_array,
    TypeId.CHAR: CdrReader.int8_array,
    TypeId.FLOAT32: CdrReader.float32_array,
    TypeId.FLOAT64: CdrReader.float64_array,
    TypeId.INT8: CdrReader.int8_array,
    TypeId.UINT8: CdrReader.uint8_array,
    TypeId.INT16: CdrReader.int16_array,
    TypeId.UINT16: CdrReader.uint16_array,
    TypeId.INT32: CdrReader.int32_array,
    TypeId.UINT32: CdrReader.uint32_array,
    TypeId.INT64: CdrReader.int64_array,
    TypeId.UINT64: CdrReader.uint64_array,
    TypeId.STRING: CdrReader.string_array,
    TypeId.WSTRING: _parse_w_string_array,
}

# Type aliases already imported from _plans, no need to redefine


_FIELD_WRITERS = {
    "bool": CdrWriter.write_boolean,
    "byte": CdrWriter.write_uint8,
    "char": CdrWriter.write_int8,
    "float32": CdrWriter.write_float32,
    "float64": CdrWriter.write_float64,
    "int8": CdrWriter.write_int8,
    "uint8": CdrWriter.write_uint8,
    "int16": CdrWriter.write_int16,
    "uint16": CdrWriter.write_uint16,
    "int32": CdrWriter.write_int32,
    "uint32": CdrWriter.write_uint32,
    "int64": CdrWriter.write_int64,
    "uint64": CdrWriter.write_uint64,
    "string": CdrWriter.write_string,
    "wstring": _write_w_string,
}

_ARRAY_WRITERS = {
    "bool": CdrWriter.write_boolean_array,
    "byte": CdrWriter.write_uint8_array,
    "char": CdrWriter.write_int8_array,
    "float32": CdrWriter.write_float32_array,
    "float64": CdrWriter.write_float64_array,
    "int8": CdrWriter.write_int8_array,
    "uint8": CdrWriter.write_uint8_array,
    "int16": CdrWriter.write_int16_array,
    "uint16": CdrWriter.write_uint16_array,
    "int32": CdrWriter.write_int32_array,
    "uint32": CdrWriter.write_uint32_array,
    "int64": CdrWriter.write_int64_array,
    "uint64": CdrWriter.write_uint64_array,
    "string": CdrWriter.write_string_array,
    "wstring": _write_w_string_array,
}


def _handle_primitive(
    reader: CdrReader, field_values: dict[str, Any], action: PrimitiveAction
) -> None:
    """Handle primitive type reading."""
    reader_fn = _TYPE_READERS[action.data]
    value = reader_fn(reader)
    field_values[action.target] = value


def _handle_primitive_array(
    reader: CdrReader, field_values: dict[str, Any], action: PrimitiveArrayAction
) -> None:
    """Handle primitive array type reading."""
    array_size = action.size
    array_length = array_size if array_size is not None else reader.sequence_length()
    reader_fn = _TYPE_ARRAY_READERS[action.data]
    value = reader_fn(reader, array_length)
    field_values[action.target] = value


def _handle_complex(reader: CdrReader, field_values: dict[str, Any], action: ComplexAction) -> None:
    """Handle complex type reading."""
    value = _execute_plan(action.plan, reader)
    field_values[action.target] = value


def _handle_complex_array(
    reader: CdrReader, field_values: dict[str, Any], action: ComplexArrayAction
) -> None:
    """Handle complex array type reading."""
    nested_plan = action.plan
    array_length = action.size if action.size is not None else reader.uint32()

    # Pre-allocate array and fill manually for better performance
    array: list[DecodedMessage] = [None] * array_length  # type: ignore[list-item]
    for i in range(array_length):
        array[i] = _execute_plan(nested_plan, reader)

    field_values[action.target] = array


def _handle_primitive_group(
    reader: CdrReader, field_values: dict[str, Any], action: PrimitiveGroupAction
) -> None:
    """Handle primitive group type reading (optimized grouped primitives)."""
    # Read each primitive in the group and set the corresponding field
    for field_name, type_id in action.targets:
        reader_fn = _TYPE_READERS[type_id]
        value = reader_fn(reader)

        # Skip setting fields for padding entries
        if type_id != TypeId.PADDING:
            field_values[field_name] = value


# Direct dispatch table for maximum performance
_ACTION_HANDLERS = {
    ActionType.PRIMITIVE: _handle_primitive,
    ActionType.PRIMITIVE_ARRAY: _handle_primitive_array,
    ActionType.PRIMITIVE_GROUP: _handle_primitive_group,
    ActionType.COMPLEX: _handle_complex,
    ActionType.COMPLEX_ARRAY: _handle_complex_array,
}


def _execute_plan(plan: PlanList, reader: CdrReader) -> DecodedMessage:
    """Execute a pre-computed parsing plan to deserialize a message."""
    msg_class, actions = plan

    # Collect field values instead of creating instance immediately
    field_values = {}

    # Handle empty message case
    if not actions:
        reader.uint8()  # structure_needs_at_least_one_member
        return msg_class(**field_values)

    for action in actions:
        # Inline primitive handling for maximum speed
        if action.type == ActionType.PRIMITIVE:
            reader_fn = _TYPE_READERS[action.data]
            field_values[action.target] = reader_fn(reader)
        elif action.type == ActionType.PRIMITIVE_GROUP:
            _ACTION_HANDLERS[action.type](reader, field_values, action)
        else:
            _ACTION_HANDLERS[action.type](reader, field_values, action)

    return msg_class(**field_values)


def create_decoder(plan: PlanList) -> DecoderFunction:
    """Create a decoder function from an execution plan.

    This is the main entry point for the dynamic parser implementation.
    It converts a plan generated by _planner.py into an executable decoder.

    :param plan: The execution plan generated by _planner.py
    :return: A decoder function that can deserialize message bytes
    """

    def decoder(data: bytes) -> DecodedMessage:
        reader = CdrReader(data)
        return _execute_plan(plan, reader)

    return decoder


def _write_complex_type(
    fields: list[Field],
    msgdefs: dict[str, MessageSpecification],
    ros2_msg: Any,
    writer: CdrWriter,
) -> None:
    if len(fields) == 0:
        # In case a message definition definition is empty, ROS 2 adds a
        # `uint8 structure_needs_at_least_one_member` field when converting to IDL,
        # to satisfy the requirement from IDL of not being empty.
        # See also https://design.ros2.org/articles/legacy_interface_definition.html
        writer.write_uint8(0x00)

    for field in fields:
        ftype = field.type
        if not ftype.is_primitive_type():
            # Complex type
            nested_definition = msgdefs.get(f"{ftype.pkg_name}/{ftype.type}")
            if nested_definition is None:
                raise ValueError(
                    f'Message definition not found for field "{field.name}" with '
                    'type "{ftype.type}"'
                )

            if ftype.is_array:
                array: list[Any] | tuple[Any] | Any = _get_property(ros2_msg, field.name)
                if array is None:
                    array = []
                if not isinstance(array, list):
                    raise ValueError(
                        f'Field "{field.name}" is not an array but has array type "{ftype.type}[]"'
                    )

                if ftype.is_fixed_size_array() and ftype.array_size is not None:
                    # Fixed length array, ensure the input array is the correct length
                    while len(array) < ftype.array_size:
                        array.append({})
                    if len(array) > ftype.array_size:
                        array = array[: ftype.array_size]

                    for item in array:
                        _write_complex_type(
                            nested_definition.fields,
                            msgdefs,
                            item,
                            writer,
                        )
                else:
                    # Limit the array to the upper bound length, if present
                    if (
                        ftype.is_upper_bound
                        and ftype.array_size is not None
                        and len(array) > ftype.array_size
                    ):
                        array = array[: ftype.array_size]

                    # Dynamic length array, write a uint32 prefix
                    writer.write_uint32(len(array))
                    # Write the array values
                    for item in array:
                        _write_complex_type(
                            nested_definition.fields,
                            msgdefs,
                            item,
                            writer,
                        )
            else:
                _write_complex_type(
                    nested_definition.fields,
                    msgdefs,
                    _get_property(ros2_msg, field.name) or {},
                    writer,
                )
        # Primitive type
        elif ftype.is_array:
            array: list[Any] | tuple[Any] | Any = _get_property(ros2_msg, field.name)
            if array is None:
                array = []
            if (
                not isinstance(array, list)
                and not isinstance(array, tuple)
                and not isinstance(array, bytes)
                and not isinstance(array, py_array.array)
            ):
                raise ValueError(
                    f'Field "{field.name}" is not an array ({type(array)}) but has array type '
                    f'"{ftype.type}[]"'
                )

            # Special handling for bytes
            if isinstance(array, bytes) or (
                isinstance(array, py_array.array) and array.typecode == "B"
            ):
                byte_array: bytes = array if isinstance(array, bytes) else array.tobytes()
                if ftype.type not in {"uint8", "byte"}:
                    raise ValueError(
                        f'Field "{field.name}" has type "uint8[]" but has type "{ftype.type}[]"'
                    )

                if ftype.is_fixed_size_array() and ftype.array_size is not None:
                    # Fixed length byte array, ensure the input array is the correct length
                    while len(byte_array) < ftype.array_size:
                        byte_array += b"\0"
                    if len(byte_array) > ftype.array_size:
                        byte_array = byte_array[: ftype.array_size]

                    writer.write_bytes(byte_array)
                else:
                    # Limit the byte array to the upper bound length, if present
                    if (
                        ftype.is_upper_bound
                        and ftype.array_size is not None
                        and len(array) > ftype.array_size
                    ):
                        byte_array = byte_array[: ftype.array_size]

                    # Dynamic length byte array, write a uint32 prefix
                    writer.write_uint32(len(byte_array))
                    # Write the byte array values
                    writer.write_bytes(byte_array)
            else:
                array_writer_fn = _ARRAY_WRITERS.get(ftype.type)
                if array_writer_fn is None:
                    raise NotImplementedError(f"Writing for type {ftype.type}[] is not implemented")

                if ftype.is_fixed_size_array() and ftype.array_size is not None:
                    # Convert tuples to lists
                    list_array = (
                        list(array) if isinstance(array, (tuple, py_array.array)) else array
                    )
                    # Fixed length array, ensure the input array is the correct length
                    while len(list_array) < ftype.array_size:
                        list_array.append(None)
                    if len(list_array) > ftype.array_size:
                        list_array = list_array[: ftype.array_size]

                    list_array: list[Any] = _coerce_values(
                        list_array, ftype.type, field.default_value
                    )
                    array_writer_fn(writer, list_array)
                else:
                    # Limit the array to the upper bound length, if present
                    if (
                        ftype.is_upper_bound
                        and ftype.array_size is not None
                        and len(array) > ftype.array_size
                    ):
                        array = array[: ftype.array_size]

                    array = list(array) if isinstance(array, py_array.array) else array
                    array = _coerce_values(array, ftype.type, field.default_value)

                    # Dynamic length array, write a uint32 prefix
                    writer.write_uint32(len(array))
                    # Write the array values
                    array_writer_fn(writer, array)
        else:
            writer_fn = _FIELD_WRITERS.get(ftype.type)
            if writer_fn is None:
                raise NotImplementedError(f"Writing for type {ftype.type} is not implemented")

            value = _get_property(ros2_msg, field.name)
            value: Any = _coerce_value(value, ftype.type, field.default_value)
            writer_fn(writer, value)


def _get_property(obj: Any, name: str) -> Any:
    if hasattr(obj, name):
        return getattr(obj, name)
    try:
        return obj[name]
    except (KeyError, TypeError):
        return None


def _coerce_value(value: Any, type_name: str, default_value: DefaultValue | None) -> PrimitiveValue:
    if isinstance(default_value, list):
        raise TypeError("Default value for primitive types cannot be an array")

    if type_name in {"string", "wstring"}:
        return (
            str(value) if value is not None else default_value if default_value is not None else ""
        )
    if type_name in {"float32", "float64"}:
        return (
            float(value)
            if value is not None
            else default_value
            if default_value is not None
            else 0.0
        )
    if type_name in {
        "byte",
        "char",
        "int8",
        "uint8",
        "int16",
        "uint16",
        "int32",
        "uint32",
        "int64",
        "uint64",
    }:
        return (
            int(value) if value is not None else default_value if default_value is not None else 0
        )
    if type_name == "bool":
        return (
            bool(value)
            if value is not None
            else default_value
            if default_value is not None
            else False
        )
    raise TypeError(f'coercion for type "{type_name}" is not implemented')


def _coerce_values(
    values: list[Any] | tuple[Any],
    type_name: str,
    default_value: DefaultValue | None,
) -> list[PrimitiveValue]:
    return [_coerce_value(value, type_name, default_value) for value in values]
